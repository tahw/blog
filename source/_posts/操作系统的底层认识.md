title: 操作系统的底层认识
author: jianghe
tags:
  - 并发
categories:
  - 并发
date: 2021-04-20 12:31:00
---
# 冯诺依曼计算机模型
&nbsp;&nbsp;&nbsp;&nbsp;现在计算机模型都是基于-<font color='red'><b>冯诺依曼计算机模型</b></font>
&nbsp;&nbsp;&nbsp;&nbsp;计算机在运行时，先从内存中取出第一条指令，通过控制器的译码，按指令的要求，从存储器中取出数据进行指定的运算和逻辑操作等加工，然后再按地址把结果送到内存中。接下来，再取出第二条指令，在控制器的指挥下完成规定操作，依次进行下去。直至遇到停止指令。
&nbsp;&nbsp;&nbsp;&nbsp;程序与数据一样存储，按程序编排的顺序，一步一步的取出指令，自动完成指令规定的操作是计算机最基本的工作模型。这个就是冯.诺依曼计算机模型。

![冯诺依曼计算机模型](/images/pasted-20.png)

<!-- more -->

## 计算机五大核心组成部分
1. 控制器(control)：是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。
2. 运算器(Datapath)：对数据进行各种算数运算和逻辑运算，即对数据进行加工
3. 存储器(Memory)：存储器的功能是存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。
4. 输入(Input system)：输入设备是计算机的重要组成部分，输入设备与输出设备合你 为外部设备，简称外设，输入设备的作用是将程序、原始数据、文字、字符、控制命令或现 场采集的数据等信息输入到计算机。常见的输入设备有键盘、鼠标器、光电输入机、磁带 机、磁盘机、光盘机等。
5. 输出(Output system)：输出设备与输入设备同样是计算机的重要组成部分，它把外 算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来。 微机常用的输出设备有显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等。

## 现代计算机模型
&nbsp;&nbsp;&nbsp;&nbsp;现在的计算机就是通过冯诺依曼计算机模型来应用出来的，见下图。其中我们最主要是关心CPU和内存。

![现代计算机模型](/images/pasted-21.png)

## cpu指令结构

cpu内部结构
* 控制单元
	* 控制单元是整个CPU的指挥控制中心，由指令寄存器IR（Instruction Register）、指 令译码器ID（Instruction Decoder）和 操作控制器OC（Operation Controller） 等组 成，对协调整个电脑有序工作极为重要。它根据用户预先编好的程序，依次从存储器中取出 各条指令，放在指令寄存器IR中，通过指令译码（分析）确定应该进行什么操作，然后通过 操作控制器OC，按确定的时序，向相应的部件发出微操作控制信号。操作控制器OC中主要 包括：节拍脉冲发生器、控制矩阵、时钟脉冲发生器、复位电路和启停电路等控制逻辑。
* 运算单元
	* 运算单元是运算器的核心。可以执行算术运算（包括加减乘数等基本运算及其附加运 算）和逻辑运算（包括移位、逻辑测试或两个值比较）。相对控制单元而言，运算器接受控 制单元的命令而进行动作，即运算单元所进行的全部操作都是由控制单元发出的控制信号来 指挥的，所以它是执行部件。
* 数据单元
	* 存储单元包括 CPU 片内缓存Cache和寄存器组，是 CPU 中暂时存放数据的地方，里 面保存着那些等待处理的数据，或已经处理过的数据，CPU 访问寄存器所用的时间要比访 问内存的时间短。 寄存器是CPU内部的元件，寄存器拥有非常高的读写速度，所以在寄存 器之间的数据传送非常快。采用寄存器，可以减少 CPU 访问内存的次数，从而提高了 CPU 的工作速度。寄存器组可分为专用寄存器和通用寄存器。专用寄存器的作用是固定的，分别 寄存相应的数据；而通用寄存器用途广泛并可由程序员规定其用途。

![cpu内部结构](/images/pasted-22.png)

## CPU缓存结构
现在CPU为了提升执行效率，减少cpu与内存的交互，一般在CPU设置多级缓存
* L1 cache，分为指令缓存和数据缓存，逻辑核独占
* L2 cache，物理核独占，逻辑核共享
* L3 cache，所有物理核共享
> 物理核：可以看的到的，真实的cpu核
逻辑核：在同一个物理核内，逻辑层面的核。
超线程：超线程可以在一个逻辑核等待指令执行的间隔(等待从cache或内存中获取下一条指令)，把时间片分配到另一个逻辑核。高速在这两个逻辑核之间切换，让应用程序感知不到这个间隔，误认为自己是独占了一个核。
<font color='red'></b>一个CPU有多个物理核，如果开启了超线程，一个物理核可以分成n个逻辑核，n为超线程的数量。
其中一台机器可以有多个CPU，但是CPU之前的缓存是不共享的</b></font>
Runtime.getRuntime().availableProcessors()是逻辑核数

![cpu缓存结构](/images/pasted-23.png)

* 存储器的大小：内存>L3>L2>L1>寄存器
* 存储器速度快慢排序：寄存器>L1>L2>L3>内存
* 缓存最小的存储单位是-缓存行(cache line)，缓存大小默认64Byte，如果对象大小大于64Byte，可以采用多个缓存行存储

### CPU读取存储器数据的过程

```
1. CPU要取寄存器X的值，直接读取寄存器
2. CPU要取L1 cache的某个值，把cacheline锁住，把数据拿来，解锁。没有锁住就慢了
3. CPU要取L2 cache的某个值，L2开始加锁，加锁以后把数据复制到L1，执行上面的L1的步骤，再解锁
4. CPU要取L3 cache的某个值，L3复制到L2，L2复制到L1，L1复制寄存器
5. CPU要取内存中的数据，通知内存控制器占用总线带宽，通知内存加锁，发起内存读请求，等待回应，回应数据保存，复制到L3，然后复制到L2，然后复制到L1，最后复制到寄存器，之后解除总线锁定
```

### CPU为何有一个高速缓存
CPU在摩尔定律指导下，每18个月翻一番的速度，而内存和硬盘速度远不及CPU速度。为了解决这个问题，CPU中内置了少量的高速缓存以解决I/o速度和CPU运算速度之间的不匹配问题。在CPU访问存储设备时，无论是存储数据或者指令，都趋于一片连续的区域中，这就叫做局部性原则
```
时间局部性：如果一个信息正在被访问，那么近期它很有可能还会被访问。比如循环、递归、方法的反复调用等。
空间局部性：如果一个存储器的位置被引用，那么将来它附近的位置也会被引用。比如顺序执行的代码、连续创建的两个对象、数组等。

```
空间局部性的例子
```java
# first 比 second方式快一点，是因为再引用数组位置时，它附近的位置也引用了，导致会快一点
private static final int RUNS = 100;

    private final static int rows = 1024 * 1024;

    private final static int cols = 6;

    private static Long[][] data = new Long[rows][cols];

    public static void main(String[] args) {

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                data[i][j] = 1L;
            }
        }

        System.out.println("first");
        long first = System.currentTimeMillis();
        Long firstNum = 0L;
        for (int r = 0; r < RUNS; r++) {
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    firstNum += data[i][j];
                }
            }
        }
        System.out.println("firstNum="+firstNum);
        System.out.println("first ="+(System.currentTimeMillis()-first)); //2700
        System.out.println("second");
        long second = System.currentTimeMillis();
        Long secondNum = 0L;
        for (int r = 0; r < RUNS; r++) {
            for (int i = 0; i < cols; i++) {
                for (int j = 0; j < rows; j++) {
                    secondNum += data[j][i];
                }
            }
        }
        System.out.println("secondNum="+secondNum);
        System.out.println("second ="+(System.currentTimeMillis()-second));  // 3249
    }
```

### CPU运行安全等级
* ring0
	* 操作系统内部的指令
* rong1
	* 没有使用
* rong2
	* 没有使用
* rong3
	* 用户程序的指令
> JVM创建线程，线程阻塞唤醒是重型操作了，因为CPU要切换运行状态

例子：JVM创建线程CPU的过程
> 1. CPU从ring3切换到ring0，创建线程，调用p_thread库
2. 线程创建完成后，CPU从ring0切换到ring3
3. 执行java程序
4. CPU从ring3切换到ring0，销毁


# 操作系统内存管理

## 执行空间保护

操作系统有用户空间与系统空间两个概念，目的也是为了做到程序运行安全隔离与稳定，以32位4G大小内存的空间来说。它的寻址地址为2^32个地址。
![内容空间](/images/pasted-24.png)

&nbsp;&nbsp;&nbsp;&nbsp;Linux为内核代码和数据结构预留了几个页框，这些页永远不会被转出到磁盘上。从0x00000000到0xC0000000（PAGE_OFFSET）的线性地址可由用户代码和内核代码进行引用（<font color='red'><b>用户空间</b></font>），从0xC0000000（PAGE_OFFSET）到0xFFFFFFFF的线性地址只能由内核代码进行访问（<font color='red'><b>内核空间</b></font>）。内核空间及其数据结构都必须位于在1GB的地址空间中，但是对于此地址空间而言，更大的消费者是物理地址虚拟映射。而3GB可以用于用户应用程序。
&nbsp;&nbsp;&nbsp;&nbsp;进程与线程只能运行在用户模式（user mode）与内核模式(kernel mode)下。用户程序运行在用户模式下，而系统调用运行在内核模式下。这两种使用的堆栈是不一样的。用户方式下用的是 一般的堆栈(用户空间的堆栈)，而内核方式下用的是固定大小的堆栈（内核空间的堆栈，一般为一个内存页的大小），即每个进程与线程其实有两个堆栈，分别运行在用户态与内核态。

### 用户线程模型(ULT)
用户程序实现，不依赖系统内核，应用提供创建、同步、调度和管理线程的函数来创建用户线程。不需要用户态/内核态切换，速度快。内核对ULT无感知，线程阻塞则进程（包括它所有的线程）阻塞。

![用户线程模型](/images/pasted-26.png)

### 内核线程模型(KLT)
内核保存线程的状态和上下文信息，线程阻塞不会引起进程阻塞。在多处理器系统上，多线程在多处理器上并行运行。线程的创建、调度和管理由内核完成，效率比ULT慢，比进程效率快。

![内核线程模型](/images/pasted-25.png)

> 那JVM是什么线程模型呢？其实JVM是采用KLT。

# 进程和线程

## 进程
现代操作系统在运行一个程序时，会为其创造一个进程。进程是OS资源分配的最小单元。像启动一个java程序，计算机就会启动一个进程。

## 线程
线程是OS调度CPU的最小单元。也叫做轻量级进程。在一个进程里可以有多个线程，这些线程都拥有各自的计数器、堆栈和局部变量表等属性。并且能够访问共享的内存变量。CPU在这些线程上高速切换，让使用者感觉到这些线程在同时执行，即并发的概念。

![线程上下文切换过程](/images/pasted-28.png)

`vmstat 1，其中cs就是上下文切换，上下文存放在TSS（Task State Segment）`
![线程上下文切换](/images/pasted-27.png)


# 虚拟机指令集架构
虚拟机指令集架构主要分为两种：
1. 栈指令集架构
2. 寄存器指令集架构

## 栈指令集架构
1. 设计和实现更简单,适用于资源受限的系统; 
2. 避开了寄存器的分配难题:使用零地址指令方式分配; 
3. 指令流中的指令大部分是零地址指令,其执行过程依赖与操作栈,指令集更小,编译器 容易实现; 
4. 不需要硬件支持,可移植性更好,更好实现跨平台。

## 寄存器指令集架构
1. 典型的应用是x86的二进制指令集:比如传统的PC以及Android的Davlik虚拟机。 
2. 指令集架构则完全依赖硬件,可移植性差。 
3. 性能优秀和执行更高效。 
4. 花费更少的指令去完成一项操作。 
5. 在大部分情况下,基于寄存器架构的指令集往往都以一地址指令、二地址指令和三 地址指令为主,而基于栈式架构的指令集却是以零地址指令为主。

> jvm是栈指令集架构，可移植性好