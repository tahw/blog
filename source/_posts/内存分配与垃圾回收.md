title: 内存分配与垃圾回收
author: jianghe
toc: true
tags:
  - jvm
categories:
  - jvm
date: 2021-03-09 19:31:00
---
# jvm内存区域

之所以会选中jvm的内存区域划分为多个不同的内存区，是因为每一个独立的内存区都拥有各自的用途。
其中一部分的内存区域和jvm生命周期保持一致
另外一部分的内存区域和线程的生命周期保持一致

![jvm内存区域](/images/pasted-17.png)

# 线程共享内存区

允许被所有线程共享访问的一类内存区，包括堆区、方法区和运行时常量池三个内存区。

## 堆区
堆（heap）,Java堆区在JVM启动的时候被创建，并且它在实际的内存空间中可以是不连续的。
堆（heap）区是一块用于存储对象实例的内存区，同时也是GC执行垃圾回收的重点区域，正式因为java堆区是GC重点回收区域，那么GC极有可能在大内存的使用和回收上成为性能瓶颈。
> 为了解决问题，考虑是否一定需要将对象实例存储到Java堆区中。其中逃逸分析与栈上分配等优化技术同样也是降低GC回收频率与提升GC回收效率的方式。

堆还分为新生代（YoungGen）和老年代（OldGen）,其中新生代也可以分为Eden空间、From Survivor空间和To Survivor空间。

![堆区的分代](/images/pasted-18.png)

`-Xmx`表示堆区最大内存
`-Xms`表示堆区起始内存
一旦堆中的内存大小大于最大内存，就会抛出OutOfMemoryError异常

## 方法区
| jdk版本 | 方法区实现  | 运行时常量池位置  |	存储信息	|
|  ----  | ----  | ----  | ----  |
| <1.6  | PermGen space（永久代） | PermGen space（永久代） | 运行时常量池、变量、字段和方法数据、构造函数和普通方法的字节码内容、类和实例和接口初始化需要用到的特殊方法等数据 |
| 1.7  | PermGen space（永久代） | Heap（堆） | Heap（堆） |
| 1.8  | Metaspace（元空间）	 | Heap（堆） | Heap（堆） |

由于主流的jdk版本采用的是1.8版本，这里我们主要介绍jdk1.8版本方法区
元空间（Metaspace），是方法区的一种实现，其中元空间是属于本地内存中的，之前的方法区的实现是存储在堆中。然后元空间存储类的元信息，而静态变量和常量池都并入堆中。

### Jvm常量池

#### Class文件常量池
```java
class JavaBean{
    private int value = 1;
    public String s = "abc";
    public final static int f = 0x101;

    public void setValue(int v){
        final int temp = 3;
        this.value = temp + v;
    }

    public int getValue(){
        return value;
    }
}
```
	* 编写.java文件编译为.class文件格式的二进制数据存放在磁盘中
	* 非运行时常量池，在编译阶段以及确定
	* 存放字面量和符号引用
		* 字面量
			* 文本字符串
            
              ```java
               #9 = Utf8               s
               #3 = String             #31            // abc
               #31 = Utf8              abc
              ```
			* 用final修饰的成员变量，包括静态变量、实例变量和局部变量
            
              ```java
              #11 = Utf8               f
              #12 = Utf8               ConstantValue
              #13 = Integer            257
              ```
			* 存在常量池的字面量，指的是数据的值，也就是`abc`和`0x101(257)`，通过对常量池的观察可知这两个字面量是确实存在于常量池的。而对于基本数据类型，也就是上面的`private int value = 1`，常量池只保留他的字段描述符`I(1反编译出来的结果)`和字段的名称`value`，他们的字面量不会存在于常量池中
		* 符号引用
			* 类和接口的全限定名，也就是`Ljava/lang/String;`这样，主要用于在运行时解析得到类的直接引用
            * 字段的名称和描述符，字段也就是类或者接口中声明的变量，包括类级别变量（static）和实例级的变量
            * 方法的名称和修饰符，也就是参数类型+返回值类型        

#### 运行时常量池

运行时常量池是方法区的一部分，所以也是全局共享的。jvm在执行过程中，需要经过<b>加载、连接(验证、准备、解析)、初始化</b>，在第一步的<b>加载</b>，虚拟机需要做下面3件事

	    * 通过一个类的“全限定名”来获取此类的二进制字节流
		* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
		* 在内存中生成一个类代表这类的java.lang.Class对象，作为方法区这个类的各种数据访问的入口

> 这个Class对象和实例对象是不同的，类对象是在类加载的时候生成的，实例对象是调用new之后创建的
上面第二条，将class字节流代表的静态存储结构转化为方法区的运行时数据结构，其中就包含class文件常量池进入运行时常量池的过程。不同的类公用一个运行时常量池，同时在进入运行时常量池的过程中，多个class文件中常量池中相同的字符串只会存在一份在运行时常量池中。


运行时常量池的作用是存储class文件常量池中的符号信息。运行时常量池中保存着一些class文件中描述的符号引用，同时在类加载的<b>“解析阶段”</b>还会将这些<b>符号引用</b>所翻译出来的<b>直接引用(直接指向实例对象的指针)</b>存储在运行时常量池中。

> 运行时常量池相对于class常量池一大特性就是其具有<b>动态性</b>，Java规范并不要求常量只能在运行时才产生，也就是说运行时常量池中的内容并不全部来自class文件常量池，class文件常量池并非运行时常量池的唯一数据输入口；<b>在运行时可以通过代码生成常量并将其放入常量池中</b>，这种特性被用的较多的是String.intern()

#### 全局字符串常量池

	- 不同于基本数据类型，String类型是一个final对象，他的字面量存在于class文件常量池中，但是运行期行为却与普通变量常量不同
    - jdk1.7中，字符串常量池和类引用被移动到Java堆中(与运行时常量池分离)，因此不同版本的String行为也有差异
    
```java
String s0 = "hello";
String s1 = new String("hello");
```
- 第一种的方式声明的字面量`hello`是在<font color='red'><b>编译器</b></font>就确定的，它会直接进入到class文件常量池中，当运行期间在全局字符串常量池中会保存它的一个引用，实际上最终还是要在堆中创建一个`yellow`对象
- 第二种方式使用`new String()`，也就是调用了String类的构造函数，我们知道new指令是创建一个类的实例对象并完成加载初始化，因此这个字符串对象是在<font color='red'><b>运行期</b></font>确定的，创建的字符串对象是在堆内存上
- `s0 == s1`，返回是false，s0和s1都存在堆上，但是地址肯定不同

```java
String s1 = "Hello";
String s2 = "Hello";
String s3 = "Hel" + "lo";
String s4 = "Hel" + new String("lo");
String s5 = new String("Hello");
String s7 = "H";
String s8 = "ello";
String s9 = s7 + s8;

System.out.println(s1 == s2);  // true
System.out.println(s1 == s3);  // true
System.out.println(s1 == s4);  // false
System.out.println(s1 == s9);  // false
```
- s1 == s2
	- 这个就很好理解了，因为字面量`Hello`在运行期间会进入到全局字符串常量池，同一份字面量只会保留一份，所有引用都指向这一份字符串，自然引用的地址也就相同了
- s1 == s3
	- 编译优化，编译器会直接在Class文件常量池存的是`Hello`，跟第一种是一样的
- s1 != s4
	- `new String("lo")`在堆中创建一个String对象，而`Hel`字面量是通过另一种操作在堆中创建对象，这两个在堆中不同的地方创建的对象是通过`StringBuilder.append`方法拼接出来的，并且最终会调用`StringBuilder.toString`方法输出，最终拼出来的String对象，地址肯定是不一样的
    ```java
    @Override
    public String toString() {
        // Create a copy, don't share the array
        return new String(value, 0, count);
    }
    ```
- s1 != s9
	- 字面量会存在`Hello`、`H`、`ello`，运行期间会创建`H`和`ello`对象，通过`StringBuilder.append`方法拼接出来的，最终还是会重新生成String对象，地址肯定是不一样的。
    
> 字符串常量池的概率：字符串常量池是Jvm所维护的一个字符串实例的引用表，在Hotspot vm中，他是一个叫做String Table的全局表。在字符串常量池中维护的是字符串实例的引用，底层C++实现就是一个HashTable。这些被维护的引用所指的字符串实例，被称为”被驻留的字符串“或”interned String“或通常所说的”进入了字符串常量池的字符串“。
运行时常量池在方法区(Non-heap)，而JDK1.7后，字符串常量池被移到了heap区，因此两者根本就不是一个概念

#### 基本类型包装类对象常量池

java 中基本类型的包装类的大部分都实现了常量池技术，这些类是`Byte、Short、Integer、Long、Character、Boolean`，另外两种浮点数没有实现。另外上面这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。其中会包含自动拆箱和自动装箱