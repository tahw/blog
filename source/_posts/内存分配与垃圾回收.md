title: 内存分配与垃圾回收
author: jianghe
tags:
  - jvm
categories:
  - jvm
date: 2021-03-09 19:31:00
---
### 1. jvm内存区域

之所以会选中jvm的内存区域划分为多个不同的内存区，是因为每一个独立的内存区都拥有各自的用途。
其中一部分的内存区域和jvm生命周期保持一致
另外一部分的内存区域和线程的生命周期保持一致

![jvm内存区域](/images/pasted-17.png)

### 2. 线程共享内存区

允许被所有线程共享访问的一类内存区，包括堆区、方法区和运行时常量池三个内存区。

#### 2.1 堆区
堆（heap）,Java堆区在JVM启动的时候被创建，并且它在实际的内存空间中可以是不连续的。
堆（heap）区是一块用于存储对象实例的内存区，同时也是GC执行垃圾回收的重点区域，正式因为java堆区是GC重点回收区域，那么GC极有可能在大内存的使用和回收上成为性能瓶颈。
> 为了解决问题，考虑是否一定需要将对象实例存储到Java堆区中。其中逃逸分析与栈上分配等优化技术同样也是降低GC回收频率与提升GC回收效率的方式。

堆还分为新生代（YoungGen）和老年代（OldGen）,其中新生代也可以分为Eden空间、From Survivor空间和To Survivor空间。

![堆区的分代](/images/pasted-18.png)

`-Xmx`表示堆区最大内存
`-Xms`表示堆区起始内存
一旦堆中的内存大小大于最大内存，就会抛出OutOfMemoryError异常

#### 2.2 方法区
| jdk版本 | 方法区实现  | 运行时常量池位置  |	存储信息	|
|  ----  | ----  | ----  | ----  |
| <1.6  | PermGen space（永久代） | PermGen space（永久代） | 运行时常量池、变量、字段和方法数据、构造函数和普通方法的字节码内容、类和实例和接口初始化需要用到的特殊方法等数据 |
| 1.7  | PermGen space（永久代） | Heap（堆） | Heap（堆） |
| 1.8  | Metaspace（元空间）	 | Heap（堆） | Heap（堆） |

由于主流的jdk版本采用的是1.8版本，这里我们主要介绍jdk1.8版本方法区
元空间（Metaspace），是方法区的一种实现，其中元空间是属于本地内存中的，之前的方法区的实现是存储在堆中。然后元空间存储类的元信息，而静态变量和常量池都并入堆中。

##### 2.2.1 Jvm常量池

1. Class文件常量池
```java
class JavaBean{
    private int value = 1;
    public String s = "abc";
    public final static int f = 0x101;

    public void setValue(int v){
        final int temp = 3;
        this.value = temp + v;
    }

    public int getValue(){
        return value;
    }
}
```
	* 编写.java文件编译为.class文件格式的二进制数据存放在磁盘中
	* 非运行时常量池，在编译阶段以及确定
	* 存放字面量和符号引用
		* 字面量
			* 文本字符串
            
              ```java
               #9 = Utf8               s
               #3 = String             #31            // abc
               #31 = Utf8              abc
              ```
			* 用final修饰的成员变量，包括静态变量、实例变量和局部变量
            
              ```java
              #11 = Utf8               f
              #12 = Utf8               ConstantValue
              #13 = Integer            257
              ```
			* 存在常量池的字面量，指的是数据的值，也就是`abc`和`0x101(257)`，通过对常量池的观察可知这两个字面量是确实存在于常量池的。而对于基本数据类型，也就是上面的`private int value = 1`，常量池只保留他的字段描述符`I(1反编译出来的结果)`和字段的名称`value`，他们的字面量不会存在于常量池中
		* 符号引用
			* 类和接口的全限定名，也就是`Ljava/lang/String;`这样，主要用于在运行时解析得到类的直接引用
            * 字段的名称和描述符，字段也就是类或者接口中声明的变量，包括类级别变量（static）和实例级的变量
            * 方法的名称和修饰符，也就是参数类型+返回值类型        

2. 运行时常量池

运行时常量池是方法区的一部分，所以也是全局共享的。jvm在执行过程中，需要经过<b>加载、连接(验证、准备、解析)、初始化</b>，在第一步的<b>加载</b>，虚拟机需要做下面3件事

	    * 通过一个类的“全限定名”来获取此类的二进制字节流
		* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
		* 在内存中生成一个类代表这类的java.lang.Class对象，作为方法区这个类的各种数据访问的入口

> 这个Class对象和实例对象是不同的，类对象是在类加载的时候生成的，实例对象是调用new之后创建的
上面第二条，将class字节流代表的静态存储结构转化为方法区的运行时数据结构，其中就包含class文件常量池进入运行时常量池的过程。不同的类公用一个运行时常量池，同时在进入运行时常量池的过程中，多个class文件中常量池中相同的字符串只会存在一份在运行时常量池中。


运行时常量池的作用是存储class文件常量池中的符号信息。运行时常量池中保存着一些class文件中描述的符号引用，同时在类加载的<b>“解析阶段”</b>还会将这些<b>符号引用</b>所翻译出来的<b>直接引用(直接指向实例对象的指针)</b>存储在运行时常量池中。

> 运行时常量池相对于class常量池一大特性就是其具有<b>动态性</b>，Java规范并不要求常量只能在运行时才产生，也就是说运行时常量池中的内容并不全部来自class文件常量池，class文件常量池并非运行时常量池的唯一数据输入口；<b>在运行时可以通过代码生成常量并将其放入常量池中</b>，这种特性被用的较多的是String.intern()

3. 全局字符串常量池

	- 不同于基本数据类型，String类型是一个final对象，他的字面量存在于class文件常量池中，但是运行期行为却与普通变量常量不同
    - jdk1.7中，字符串常量池和类引用被移动到Java堆中(与运行时常量池分离)，因此不同版本的String行为也有差异

4. 基本类型包装类对象常量池